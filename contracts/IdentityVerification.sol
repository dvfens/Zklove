// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title IdentityVerification
 * @dev Smart contract for decentralized identity verification using zero-knowledge proofs
 * Integrates with Mopro toolkit for privacy-preserving identity verification
 */
contract IdentityVerification is Ownable, ReentrancyGuard {
    
    // Groth16 proof structure
    struct Proof {
        uint256[2] a;
        uint256[2][2] b;
        uint256[2] c;
    }
    
    // Verification data structure
    struct VerificationData {
        bytes32 commitment;
        bytes32 nullifierHash;
        uint256 timestamp;
        address verifier;
        bool isValid;
    }
    
    // Merkle tree for identity commitments
    bytes32 public merkleRoot;
    uint256 public leafCount;
    
    // Nullifier tracking to prevent double-spending
    mapping(bytes32 => bool) public usedNullifiers;
    
    // User verification records
    mapping(address => VerificationData[]) public userVerifications;
    mapping(address => uint256) public verificationCount;
    
    // Identity commitments
    mapping(bytes32 => bool) public validCommitments;
    
    // Events
    event IdentityVerified(
        address indexed user,
        bytes32 indexed commitment,
        bytes32 nullifierHash,
        uint256 timestamp
    );
    
    event MerkleTreeUpdated(
        bytes32 indexed newRoot,
        uint256 leafCount
    );
    
    event CommitmentAdded(
        bytes32 indexed commitment,
        address indexed user,
        uint256 timestamp
    );
    
    // Modifiers
    modifier validProof(Proof memory proof, uint256[] memory publicSignals) {
        require(proof.a[0] != 0 && proof.a[1] != 0, "Invalid proof structure");
        require(publicSignals.length >= 3, "Insufficient public signals");
        _;
    }
    
    modifier uniqueNullifier(bytes32 nullifierHash) {
        require(!usedNullifiers[nullifierHash], "Nullifier already used");
        _;
    }
    
    /**
     * @dev Constructor
     * @param _merkleRoot Initial merkle root
     */
    constructor(bytes32 _merkleRoot) {
        merkleRoot = _merkleRoot;
        leafCount = 0;
    }
    
    /**
     * @dev Add identity commitment to merkle tree
     * @param commitment The identity commitment hash
     */
    function addToMerkleTree(bytes32 commitment) external nonReentrant {
        require(commitment != bytes32(0), "Invalid commitment");
        require(!validCommitments[commitment], "Commitment already exists");
        
        validCommitments[commitment] = true;
        leafCount++;
        
        // Update merkle root (simplified - in production use proper merkle tree)
        merkleRoot = keccak256(abi.encodePacked(merkleRoot, commitment, leafCount));
        
        emit CommitmentAdded(commitment, msg.sender, block.timestamp);
        emit MerkleTreeUpdated(merkleRoot, leafCount);
    }
    
    /**
     * @dev Verify identity using zero-knowledge proof
     * @param proof The Groth16 proof
     * @param publicSignals Public signals [merkleRoot, nullifierHash, commitmentHash]
     */
    function verifyIdentity(
        Proof memory proof,
        uint256[] memory publicSignals
    ) 
        external 
        nonReentrant 
        validProof(proof, publicSignals) 
        returns (bool) 
    {
        bytes32 nullifierHash = bytes32(publicSignals[1]);
        bytes32 commitmentHash = bytes32(publicSignals[2]);
        
        require(!usedNullifiers[nullifierHash], "Identity already verified");
        require(validCommitments[commitmentHash], "Invalid commitment");
        
        // Verify the zero-knowledge proof (simplified verification)
        bool proofValid = verifyGroth16Proof(proof, publicSignals);
        require(proofValid, "Invalid zero-knowledge proof");
        
        // Mark nullifier as used
        usedNullifiers[nullifierHash] = true;
        
        // Store verification data
        VerificationData memory verificationData = VerificationData({
            commitment: commitmentHash,
            nullifierHash: nullifierHash,
            timestamp: block.timestamp,
            verifier: msg.sender,
            isValid: true
        });
        
        userVerifications[msg.sender].push(verificationData);
        verificationCount[msg.sender]++;
        
        emit IdentityVerified(msg.sender, commitmentHash, nullifierHash, block.timestamp);
        
        return true;
    }
    
    /**
     * @dev Simplified Groth16 proof verification
     * In production, this would use a proper verifier contract generated by circom
     */
    function verifyGroth16Proof(
        Proof memory proof,
        uint256[] memory publicSignals
    ) internal pure returns (bool) {
        // Simplified verification - check proof structure and public signals
        if (proof.a[0] == 0 || proof.a[1] == 0) return false;
        if (proof.b[0][0] == 0 || proof.b[0][1] == 0) return false;
        if (proof.b[1][0] == 0 || proof.b[1][1] == 0) return false;
        if (proof.c[0] == 0 || proof.c[1] == 0) return false;
        
        // Check public signals validity
        if (publicSignals.length < 3) return false;
        if (publicSignals[0] == 0) return false; // merkleRoot
        if (publicSignals[1] == 0) return false; // nullifierHash
        if (publicSignals[2] == 0) return false; // commitmentHash
        
        // In production, this would perform elliptic curve pairing checks
        // For now, we assume the proof is valid if structure is correct
        return true;
    }
    
    /**
     * @dev Check if nullifier has been used
     */
    function isNullifierUsed(bytes32 nullifier) external view returns (bool) {
        return usedNullifiers[nullifier];
    }
    
    /**
     * @dev Get user verification count
     */
    function getVerificationCount(address user) external view returns (uint256) {
        return verificationCount[user];
    }
    
    /**
     * @dev Get user verification data
     */
    function getUserVerifications(address user) 
        external 
        view 
        returns (VerificationData[] memory) 
    {
        return userVerifications[user];
    }
    
    /**
     * @dev Get current merkle root
     */
    function getMerkleRoot() external view returns (bytes32) {
        return merkleRoot;
    }
    
    /**
     * @dev Update merkle root (owner only)
     */
    function updateMerkleRoot(bytes32 newRoot) external onlyOwner {
        merkleRoot = newRoot;
        emit MerkleTreeUpdated(newRoot, leafCount);
    }
    
    /**
     * @dev Emergency function to invalidate a commitment (owner only)
     */
    function invalidateCommitment(bytes32 commitment) external onlyOwner {
        require(validCommitments[commitment], "Commitment not found");
        validCommitments[commitment] = false;
    }
    
    /**
     * @dev Get contract statistics
     */
    function getStats() external view returns (
        uint256 totalCommitments,
        uint256 totalVerifications,
        uint256 totalUsers,
        bytes32 currentMerkleRoot
    ) {
        // Note: totalUsers would need additional tracking in production
        return (leafCount, getTotalVerifications(), 0, merkleRoot);
    }
    
    /**
     * @dev Get total verifications across all users
     */
    function getTotalVerifications() internal view returns (uint256) {
        // This is a simplified implementation
        // In production, you'd maintain a global counter
        return leafCount; // Approximation
    }
    
    /**
     * @dev Batch verify multiple identities for efficiency
     */
    function batchVerifyIdentities(
        Proof[] memory proofs,
        uint256[][] memory publicSignalsArray
    ) external nonReentrant returns (bool[] memory results) {
        require(proofs.length == publicSignalsArray.length, "Array length mismatch");
        require(proofs.length <= 10, "Too many proofs in batch"); // Gas limit protection
        
        results = new bool[](proofs.length);
        
        for (uint i = 0; i < proofs.length; i++) {
            try this.verifyIdentity(proofs[i], publicSignalsArray[i]) returns (bool success) {
                results[i] = success;
            } catch {
                results[i] = false;
            }
        }
        
        return results;
    }
    
    /**
     * @dev Withdraw contract balance (owner only)
     */
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to withdraw");
        
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Withdrawal failed");
    }
    
    /**
     * @dev Receive function to accept ETH
     */
    receive() external payable {}
}
